'''Test the gitolite jenkins post-receive hook script

'''
import os
import subprocess
import tempfile
import unittest
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
import threading

import TestCfg as cfg

SCRIPT_PATH = 'components/puppet/modules/gitolite/files/jenkins.post-receive.py'
SCRIPT_SOURCE = os.path.join(cfg.product_topdir(), SCRIPT_PATH)

JENKINS_TEST_PORT = 8021
JENKINS_TEST_URL = 'http://localhost:{port}'.format(port=JENKINS_TEST_PORT)
JENKINS_TEST_TOKEN = 'gitbuild'
JENKINS_TEST_JOB = 'test_host%20build'
GITOLITE_TEST_URL = 'git@localhost'
GIT_TEST_REPO = 'test_host'

class ReqHandler(BaseHTTPRequestHandler):

    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(bytes(self.path,'utf-8'))
        self.wfile.write(b'\n')
        return
    
class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    """Handle requests in a separate thread."""
   
class TestJenkinsGitolitePostReceiveHook(unittest.TestCase):
    '''Feature: gitolite notification of jenkins on push
    as git user
    git pushes should automatically notify jenkins.
    '''
    @classmethod
    def setUpClass(cls):
        # build temporary git config file to contain the config values
        # that would normally be found in the gitolite repository config file
        server = ThreadedHTTPServer(('localhost', JENKINS_TEST_PORT), ReqHandler)
        server_thread = threading.Thread(target=server.serve_forever)
        # Exit the server thread when the main thread terminates
        server_thread.daemon = True
        server_thread.start()
        # print("Server loop running in thread:", server_thread.name)
        
    @classmethod
    def tearDownClass(cls):
        print('TearDown')
                    
    def runPostReceiveHook(self,branch):
        '''run the post-receive hook script returning the url
        
        The url is generated by the hook and output on stdout
        '''
        global lastJenkinsUri
        lastJenkinsUri = None
        
        print( SCRIPT_SOURCE )
        penv = os.environ
        penv['GL_REPO'] = GIT_TEST_REPO
        penv['GIT_CONFIG'] = self.gitCfgFn
        with subprocess.Popen(['python3.3',SCRIPT_SOURCE],
                              stdin=subprocess.PIPE,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT,
                              env=penv) as proc:
            stdinText = 'nref oref '+branch+'\n'
            scriptOut = proc.communicate(bytes(stdinText, 'utf-8'),20)
            
        scriptOutStr = scriptOut[0].decode('utf-8').strip()
        # hmmm this MAY deadlock
        return scriptOutStr
    
    def doCfgTest(self,jurl=None,jbjob=None,jbtoken=None,gurl=None):
        '''perform the actual tests for the any configuration set
        
        jurl: http://host/jenkins - the jenkins.url value
        jbjob: test_host%20build - the jenkins.build.job value
        jbtoken: gitbuild - the jenkins.build.token value
        gurl: git@host - the gitolite.url value
        '''
        # first set the temporary configuration file values
        gitCfgTmp = tempfile.NamedTemporaryFile(delete=False)
        self.gitCfgFn = gitCfgTmp.name
        gitCfgTmp.close()
        print(self.gitCfgFn)
        with open(self.gitCfgFn,'w') as f:
            if jurl:
                lines = ['[jenkins]\n',
                         '        url = {url}\n'.format(url=jurl),
                         ]
                f.writelines(lines)

            if jbjob or jbtoken:
                f.write('[jenkins "build"]\n')
                if jbjob:
                    f.write('        job = {job}\n'.format(job=jbjob))
                if jbtoken:
                    f.write('        token = {tkn}\n'.format(tkn=jbtoken))
                    
            if gurl:
                lines = ['[gitolite]\n',
                         '        url = {url}\n'.format(url=gurl),
                         ]
                f.writelines(lines)
        
        myBranch = 'devel'
        # now establish the expected values
        expUrl = None
        if jurl:
            expUrl = jurl
            if jbjob and jbtoken:
                expUrl = '/job/'+JENKINS_TEST_JOB
                expUrl += '/build?token='+JENKINS_TEST_TOKEN
                expUrl += '&cause=Cause+git+push'
            elif gurl:
                expUrl = '/git/notifyCommit?url=' + gurl
                expUrl += ':'+GIT_TEST_REPO
                expUrl += '&branches='+myBranch
            else:
                expUrl = None
            
        
        #NOW we need to run the hook with the correct env and input to stdin
        sOut= self.runPostReceiveHook(myBranch)

        os.remove(self.gitCfgFn)

        if expUrl:
            self.assertTrue(expUrl in sOut,
                            'Expected URL: {eurl}\nNot in script output: {sout}\n'
                            .format(eurl=expUrl, sout=sOut))
        else:
            self.assertTrue('not configured' in sOut,
                            'Script output does not contain: not configured\noutput: '
                            +sOut)
        
    def test_jenkin_build_job_tok(self):
        '''Scenario: git push runs specific jenkins job
        Given: post-receive is run as a gitolite hook
        and: the repository has config jenkins.url
        and: the repository has config jenkins.build.token
        and: the repository has config jenkins.build.job
        When: git push
        Then: jenkins job url is sent to jenkins server
        and: jenkins job url is output by hook
        '''
        self.doCfgTest(jurl=JENKINS_TEST_URL, 
                       jbjob=JENKINS_TEST_JOB, 
                       jbtoken=JENKINS_TEST_TOKEN)
        
    def test_jenkin_both(self):
        '''Scenario: git push runs specific jenkins job when both gitolite.url and
        jenkins.job are configured for the repo.
        Given: post-receive is run as a gitolite hook
        and: the repository has config jenkins.url
        and: the repository has config gitolite.url
        and: the repository has config jenkins.build.token
        and: the repository has config jenkins.build.job
        When: git push
        Then: jenkins job url is sent to jenkins server
        and: jenkins job url is output by hook
        '''
        self.doCfgTest(jurl=JENKINS_TEST_URL, 
                       jbjob=JENKINS_TEST_JOB, 
                       jbtoken=JENKINS_TEST_TOKEN,
                       gurl=GITOLITE_TEST_URL)

    def test_jenkin_gitolite_url(self):
        '''Scenario: git push runs jenkins jobs configured for the repository and
        branch pushed when the gitolite.url is configured for the repo.
        Given: post-receive is run as a gitolite hook
        and: the repository has config jenkins.url
        and: the repository has config gitolite.url
        When: git push
        Then: jenkins repo and branch url is sent to jenkins server
        and: jenkins repo and branch url is output by hook
        '''
        self.doCfgTest(jurl=JENKINS_TEST_URL, 
                       gurl=GITOLITE_TEST_URL)

    def test_jenkin_no_cfg(self):
        '''Scenario: git push to invalid repository configurations. A correctly
        configured repository has the 'config jenkins.url' set and either the
        'config gitolite.url' or both 'config jenkins.build.job' and
        'config jenkins.build.token' set.
        Given: post-receive is run as a gitolite hook
        and: the repository has is miss configured.
        When: git push
        Then: jenkins job url is sent to jenkins server
        and: jenkins job url is output by hook
        '''
        # everything but jenkins url
        self.doCfgTest()
        self.doCfgTest(jbjob=JENKINS_TEST_JOB, 
                       jbtoken=JENKINS_TEST_TOKEN,
                       gurl=GITOLITE_TEST_URL)        
        self.doCfgTest(jurl=JENKINS_TEST_URL)
        self.doCfgTest(jurl=JENKINS_TEST_URL,
                       jbjob=JENKINS_TEST_JOB)
        self.doCfgTest(jurl=JENKINS_TEST_URL, 
                       jbtoken=JENKINS_TEST_TOKEN)

